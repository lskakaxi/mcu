C51 COMPILER V9.52.0.0   TIMER                                                             08/22/2013 07:41:16 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\timer.obj
COMPILER INVOKED BY: E:\work\tools\Keil\C51\BIN\C51.EXE ..\timer.c ROM(COMPACT) BROWSE DEFINE(_KEIL_C_) DEBUG OBJECTEXTE
                    -ND TABS(2) OBJECT(.\timer.obj)

line level    source

   1          /* Timer 0,1 API for 89S52
   2           * Author: shuox.liu@gmail.com
   3           * Date: 2013-07-27 02:50
   4           *
   5           * When timer0 in mode3, only support one 8-bit timer
   6           */
   7          #include "mycar.h"
   8          #include "timer.h"
   9          
  10          u16 timer0_value;
  11          u16 timer1_value;
  12          void init_timer(u8 timer,
  13              timer_mode t_mode,
  14              control_mode c_mode,
  15              operation_mode o_mode)
  16          {
  17   1        u8 reg;
  18   1      
  19   1        reg = TMOD;
  20   1        switch (timer) {
  21   2        default:
  22   2        case 0:
  23   2          TR0 = 0;
  24   2          if (t_mode & 1) reg |= T0_M0;
  25   2          else reg &= ~T0_M0;
  26   2      
  27   2          if (t_mode >> 1) reg |= T0_M1;
  28   2          else reg &= ~T0_M1;
  29   2          
  30   2          if (o_mode) reg |= T0_CT;
  31   2          else reg &= ~T0_CT;
  32   2      
  33   2          if (c_mode) reg |= T0_GATE;
  34   2          else reg &= ~T0_GATE;
  35   2      
  36   2          TH0 = TL0 = 0;
  37   2          break;
  38   2        case 1:
  39   2          TR1 = 0;
  40   2          if (t_mode & 1) reg |= T1_M0;
  41   2          else reg &= ~T1_M0;
  42   2          
  43   2          if (t_mode >> 1) reg |= T1_M1;
  44   2          else reg &= ~T1_M1;
  45   2      
  46   2          if (o_mode) reg |= T1_CT;
  47   2          else reg &= ~T1_CT;
  48   2          
  49   2          if (c_mode) reg |= T1_GATE;
  50   2          else reg &= ~T1_GATE;
  51   2      
  52   2          TH1 = TL1 = 0;
  53   2          break;
  54   2        }
C51 COMPILER V9.52.0.0   TIMER                                                             08/22/2013 07:41:16 PAGE 2   

  55   1        TMOD = reg;
  56   1      }
  57          
  58          void set_timer(u8 timer, u16 count)
  59          {
  60   1        timer_mode mode;
  61   1      
  62   1        switch (timer) {
  63   2        default:
  64   2        case 0:
  65   2          mode = TMOD & (T0_M1 | T0_M0);
  66   2          switch (mode) {
  67   3          case MODE0_13b:
  68   3            TL0 = count & 0x1f;
  69   3            TH0 = count >> 5;
  70   3            break;
  71   3          default:
  72   3          case MODE1_16b:
  73   3            TH0 = count >> 8;
  74   3          case MODE2_8b_AUTOLOAD:
  75   3          case MODE3_8b_DOUBLE:
  76   3            TL0 = count & 0xff;
  77   3          }
  78   2          timer0_value = count;
  79   2          break;
  80   2        case 1:
  81   2          mode = TMOD & (T1_M1 | T1_M0);
  82   2          switch (mode) {
  83   3          case MODE0_13b:
  84   3            TL1 = count & 0x1f;
  85   3            TH1 = count >> 5;
  86   3            break;
  87   3          default:
  88   3          case MODE1_16b:
  89   3            TH1 = count >> 8;
  90   3          case MODE2_8b_AUTOLOAD:
  91   3            TL1 = count & 0xff;
  92   3          }
  93   2          timer1_value = count;
  94   2          break;
  95   2        }
  96   1      }
  97          
  98          void start_timer(u8 timer)
  99          {
 100   1        timer_mode mode;
 101   1      
 102   1        switch (timer) {
 103   2        default:
 104   2        case 0:
 105   2          ET0 = 1; TR0 = 1; break;
 106   2        case 1:
 107   2          /* timer0.1 use timer1's TR,.. */
 108   2          mode = TMOD & (T0_M1 | T0_M0);
 109   2          if (mode == MODE3_8b_DOUBLE) {
 110   3            /* default use mode 1 */
 111   3            TMOD = (TMOD & ~T1_M1) | T1_M0;
 112   3          } else {
 113   3            ET1 = 1;
 114   3            TR1 = 1;
 115   3          }
 116   2      
C51 COMPILER V9.52.0.0   TIMER                                                             08/22/2013 07:41:16 PAGE 3   

 117   2          break;
 118   2        }
 119   1      }
 120          
 121          u16 stop_timer(u8 timer)
 122          {
 123   1        timer_mode mode;
 124   1        u16 ret;
 125   1      
 126   1        switch (timer) {
 127   2        default:
 128   2        case 0:
 129   2          TR0 = 0;
 130   2          mode = TMOD & (T0_M1 | T0_M0);
 131   2          switch (mode) {
 132   3          case MODE0_13b:
 133   3            ret = (u16)((u8)TH0 << 5) + TL0 & 0x1f;
 134   3            break;
 135   3          default:
 136   3          case MODE1_16b:
 137   3            ret = (u16)(TH0 << 8) + TL0;
 138   3            break;
 139   3          case MODE2_8b_AUTOLOAD:
 140   3            ret = (u16)TL0 & 0xff;
 141   3            break;
 142   3          case MODE3_8b_DOUBLE:
 143   3            ret = (u16)TL0 & 0xff;
 144   3            break;
 145   3          }
 146   2          break;
 147   2        case 1:
 148   2          mode = TMOD & (T0_M1 | T0_M0);
 149   2          if (mode == MODE3_8b_DOUBLE) {
 150   3            TMOD = (TMOD | T1_M1 | T1_M0);
 151   3            return 0;
 152   3          }
 153   2          TR1 = 0;
 154   2          mode = TMOD & (T1_M1 | T1_M0);
 155   2          switch (mode) {
 156   3          case MODE0_13b:
 157   3            ret = (u16)((u8)TH1 << 5) + TL1 & 0x1f;
 158   3            break;
 159   3          default:
 160   3          case MODE1_16b:
 161   3            ret = (u16)(TH1 << 8) + TL1;
 162   3            break;
 163   3          case MODE2_8b_AUTOLOAD:
 164   3            ret = (u16)TL1 & 0xff;
 165   3            break;
 166   3          case MODE3_8b_HALT:
 167   3            ret = 0;
 168   3            break;
 169   3          }
 170   2      
 171   2          ret = (u16)(TH1 << 8) + TL1;
 172   2          break;
 173   2        }
 174   1      
 175   1        return ret;
 176   1      }
 177          
 178          void start_counter(u8 timer)
C51 COMPILER V9.52.0.0   TIMER                                                             08/22/2013 07:41:16 PAGE 4   

 179          {
 180   1        init_timer(timer, MODE1_16b, CTL_SW, OP_PULSE);
 181   1        start_timer(timer);
 182   1      }
 183          
 184          u16 stop_counter(u8 timer)
 185          {
 186   1        return stop_timer(timer);
 187   1      }
 188          
 189          #ifdef _KEIL_C_
 190          void timer0_isr(void) interrupt 1 using 1
 191          #else
              void timer0_isr(void) __interrupt (1) __using (1)
              #endif
 194          {
 195   1        /* enable timer0 firstly */
 196   1        TR0 = 0;
 197   1        set_timer(0, timer0_value);
 198   1        TR0 = 1;
 199   1        /* add hook time consume in this timer period */
 200   1      #ifdef TIMER0_CB_HOOK
 201   1        TIMER0_CB_HOOK;
 202   1      #endif
 203   1      }
 204          
 205          #ifdef _KEIL_C_
 206          void timer1_isr(void) interrupt 3 using 2
 207          #else
              void timer1_isr(void) __interrupt (3) __using (2)
              #endif
 210          {
 211   1        /* enable timer1 firstly */
 212   1        TR1 = 0;
 213   1        set_timer(1, timer1_value);
 214   1        TR1 = 1;
 215   1        /* add hook time consume in this timer period */
 216   1      #ifdef TIMER1_CB_HOOK
                TIMER1_CB_HOOK;
              #endif
 219   1      }
 220          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    480    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
